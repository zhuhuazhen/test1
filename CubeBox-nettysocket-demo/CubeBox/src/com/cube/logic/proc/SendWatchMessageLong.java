package com.cube.logic.proc;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
 

import com.cube.core.CubeRun;
import com.cube.core.conn.Connection;
import com.cube.core.conn.ConnectionManager;
import com.cube.event.CubeMsg;
import com.cube.event.EventEnum;
import com.cube.exception.IllegalDataException;
import com.cube.logic.Process;
import com.cube.utils.ByteBufUtils;
import com.cube.utils.HexByteToolUtil;

/**
 * app发给服务，服务再发给手表
 * @description
 * @author tengyz
 * @version 0.1
 * @date 2014年8月6日
 */
public class SendWatchMessageLong implements Process {
	private static final Logger LOG = Logger.getLogger(SendWatchMessage.class);
    
    /**
     * 要发送数据，必须对CubeMsg设置ctx和data , ctx 从ConnectionManager中获取, data必须包含replyid
     * ReplyEvent可以向ProcessRunnable注册 然后ReplyEvent.wait(timeout);
     * 在finally中删除ProcessRunnable的注册
     */
    public void excute(CubeMsg msg) throws IllegalDataException {
        String doing="error";
        Connection conn = ConnectionManager.getInstance().getConn(new String(msg.getData()));
        if(null!=conn){
        	if (conn.getCtx().channel().isWritable()) {
                String voiceString=msg.getDataString();
            	LOG.info("voiceString******" + voiceString);
                String head = voiceString.substring(0,15); //[3G*1451637827*
               	LOG.info("head******" + head);
                String length = voiceString.substring(15,19); //
                LOG.info("length1******" + length);
                String hexString = voiceString.substring(23,voiceString.length() - 1);
                LOG.info("hexString******" + hexString);
                byte[] amr =HexByteToolUtil.hexStringToBytes(hexString);
                LOG.info("amr.length******" + amr.length);
                length = Integer.toHexString((amr.length + 3));
                length = StringUtils.leftPad(length, 4, "0").toUpperCase();
                LOG.info("length2******" + length);
                
                StringBuilder build= new StringBuilder();
                build.append(HexByteToolUtil.encode(head)).append(HexByteToolUtil.encode(length)).append(HexByteToolUtil.encode("*TK,")).append(hexString).append("5D");
                LOG.info((new StringBuilder()).append("向手表发送数据=:").append(build.toString()).toString());
                //转发给手表
                ByteBuf  buff=(ByteBuf) Unpooled.wrappedBuffer(HexByteToolUtil.hexStringToBytes(build.toString()));
                //ByteBuf  buff=(ByteBuf) Unpooled.wrappedBuffer(com.cube.utils.test.hexStringToBytes("5B33472A313435313633373832372A303735442A544B2C2321414D520A7D049EC07C00FF01FCB9A32F508B262FB3F58360AF527D049EC07C00FF01FCB9A32F508B262FB3F58360AF527D049EC07C00FF01FCB9A32F508B262FB3F58360AF527D0448DAE76898419E1B9E02216D17A7CE660402DA387D044BEDFDE010A19E15AF8A4156A1BF4710B1B65C4A7D042F4CF56880A18B5CD5110B4B3B7D047C3AEA549C1C7D0451869B4AA2A9164344254918EE98B594D52340E07D048B16E74AB00BAE4B6DEE9AE7AF9A35B47231CD4A7D045093D38661890E43D416AF67BD453781CBB6129E7D044C07D37D04C1D0C72DB9B4A2F4B81E7D05C1D4314F247D0434D6EA7D02A0C1FB7D027BE0E32D14C9999DD3C539987D0457B39CD32311BCA227D8C5C2B763DD398FA172987D043C20887D029861F9F722F6CFF032EB3D3294A71FCE7D0436111C1FFC21FB47590AFA1D8F6D5450636690A47D043307743DD4E1FE004C6BDF8DC2AEAA467E5AB5D27D0436908F8673A1EE479B02CECF8A3B9095D5359AFA7D046CAC3BE04801FE086DB92978AA486C9841A99C4C7D046CF2B5E0C8C00665D6653A482452E39B311032667D046EACC5E15140000DD962A7BFEB7C38CED542A1C07D046EACC5E0C0A0AA12F9457184B6B7C792E4F20B387D045EA9C5E000C1FE1601816E75C6407C2EE1E4DA607D047D02ECC16880A000151A99FA7D020E0702C65A82CFA07D04A0B6EB6881D0FC3B90BC0FF093EAAA8131D3E7B87D04AA11454AA0A9D20B4B35774F60434284333854C67D04B2AC8FA449798346505FBBC04BC6D8CC5A1254EE7D04AB41C54AEB598B4B595683CC12B9B31EA4E20E4E7D04AB8CC5E0002B8CF099E909529A55B8A2F0C212787D04AA7D05C4F100AB84B6613F3C73BB4638AE194A36087D047785C5E0001BC624787B6688BA366A76802385F87D0497113FE0001B04802EC027C7D57D03FE908FF10DC27D04AF8CC4798005CFBCA05419FF297D04B4C406D2D21A7D04B8B084976001861F01CB6189C93F12CAF6913C6A7D04691DC4D329806A1A51FE4EAEBDD39C46F64EA4E67D047D038C8EF10065C4F0230BD1F1600706A40F7BD43A7D04169719A4C0C17D0494B87D02A518ADFCA7831A7C33E47D041DEDFD86DB412B56C47005896954DA62B657C16E7D040F2BFD87E38069C7ED7314E2828F76C875CE0BFE7D041D17FDA4D422D9E7E47D0134F068FF33091C0B34467D0446EAFDE000A79E100DE10D57BF2626C5DA367F807D041CF47D04B5C0407196E401B7C2558ED86BC8B68AA67D041C24FDC222A07C8605BD3A53951323D6DFE1AA087D041A7E07E08F805992C0A212A404CA393A8091D7CC7D040FFEFDC010E061940C76C07EB4B601F39D09D7467D041A1BC4DB9AC06187006D4E1405E220911C1F50967D041CA21CD3386048C8C26652286B786D99BCF9BFC87D040E1B1D4A96A031830B226E8074F39E727D04C4D7B47D041AA28E3DDE60618CE340C11633FE4C9A0A7924967D040E7BC37D045FC06195EE7D0476A772ACEE6F0AFCBCEE7D041BE1FF867F60618DE71AC03633D79850CE589A327D041C7BE76996A0619E21C48E31444666DA7D040004B27D041BD6FC79CF806198A531160EA11E3CC8DE0A06FE7D041CDFFD6981E4748DA4C98FA7F3B0F6A04E0348847D041CDF19E11D20498DE9A623288FE18AB441BCA8287D041CDF75E007823A57C7079909E48B2D85A577E1AA7D0437D319E1038061EF0180435635114AC194C41B007D0458ECE7E06B447434A1AFC11A5E26B70F11627D05D07D0437D3E7E0C9201833E1DA5778849E82647869D61C7D0459E719E0A722221D80F60CCEC2C84E590992853A7D0436D119E081E66C95A1A88D3B2919C2668E2991047D0437EABDE069046192C37EF8634F877D0328B5CF84907D045434FDE080624745E4838A8651459CBF947551B67D045434E7E102161E0400C3CA7EA5D913207529633C7D043727FDE0412018796CB3C184939F3389CF918DC67D0437BF74F102E61E1287D788FCD3EDB22439DBE0107D041F27FD4AA966663C14A1DF48A27E784F2EC886D67D041F57FDE11B46364295DCC4C5540B43608B4007EA7D041CDFE768DA245C2820A30644E4364F19B50B13A47D041DF2CB6892C5218C29677D03D78E584ECF181E04F67D040FF2FBC2024019979D8BA39243FE755206A202087D041CFAE697EB4030D209132F5F122952FAD1C0E2067D041F70C7E001A030D9164131E79D9E95914EC4EDB87D04368681688F261B49CFC4892DEBD295A3055F4FF27D041EE1809763C61CA3B6EFDFAE728F3498068F4FAA7D041DE139C203C009252BA7B0CF89FC69D98D41CB0A7D040FF281C2A1A031333F4B732B02B5F71772063AF67D041CDF81A4418030DDC789749EA3583066B39947B27D041D5A3FA47D038269B0E1EB01BEF33B2374A7EF5CAE7D041F5A3F0FF0E0314FF27D011F06D99DDAD478DDA0927D041E53DB4AA6A0186BD1C112D745CC4D58C104E7567D041E5EE6976000181671CFB1653EE6C7261B6F7D04747D043716810EE222302DEF7D049A7CA1D03196B3547D01F07D0454CAE76898621A69C19C041A18E1227171897B7A7D041F45741EE15574DED4A0BCB51F4CDADBAEB2092E7D045883BCF91A8410F3FB43D4B722D44E2147874C045D"));
            	conn.getCtx().writeAndFlush(buff);
                doing="ok";
                msg.getCtx().pipeline().writeAndFlush(doing);//回复app发送情况
            } else {
                LOG.info("手表不可写，无法发送数据,关闭连接");
                msg.getCtx().pipeline().writeAndFlush(doing);
                conn.getCtx().pipeline().close();
            }
        }else{
        	 LOG.info("手表未连接，无法发送数据,关闭连接");
        	 //回复app发送情况
        	 ByteBuf  buff=(ByteBuf) Unpooled.wrappedBuffer(HexByteToolUtil.hexStringToBytes(HexByteToolUtil.encode(doing)));
        	 msg.getCtx().writeAndFlush(buff);
        	 msg.getCtx().pipeline().close();
        }
    }


    
}
